### JPA에서 영속성(Persistence) 이란?

* #### Entity를 영구적으로 저장해주는 환경을 의미합니다.

#### 영속성 컨텍스트의 특징
* ##### 영속성 컨텍스트는 Entity를 식별자 값으로 구분합니다.
    Entity에서 @Id 어노테이션을 통해 지정한 멤버변수가 영속성 컨텍스트에 식별자 값으로 저장됩니다.

* ##### JPA 는 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 Entity를 데이터베이스에 반영합니다. (이런 과정을 flush라 합니다.)

* ##### 1차 캐시를 이용합니다.
    영속성 컨텍스트 내부에 존재하는 캐시(Map)를 1차 캐시라 합니다. 영속 상태의 Entity는 모두 이곳에 저장되며 키는 @Id 로 매핑한 식별자이며 값은 Entity가 인스턴스입니다. entityManager.find() 메소드를 호출하면 먼저 1차 캐시에서 Entity를 찾고, 만약 찾는 Entity가 1차 캐시에 없으면 데이터베이스에서 조회한 후 1차 캐시에 저장하고 영속 상태인 해당 객체를 반환합니다.

* ##### 객체의 동일성을 보장합니다.
    ```java
    Person taemin = new Person(1, "taemin"); // id, name
    entityManager.persist(taemin);
    Person taemin1 = entityManager.find(Person.class, 1);
    Person taemin2 = entityManager.find(Person.class, 1);
    taemin1 == taemin2 // true
    ```
    이와 같이 1차 캐시에 있는 같은 Entity 인스턴스를 반환하기 때문에 Entity의 동일성을 보장합니다.

* ##### 트랜잭션을 지원하는 쓰기 지연을 수행합니다.
    EntityManager는 트랜잭션을 commit 하기 직전까지 데이터베이스에 Entity를 저장하지 않고 영속성 컨텍스트 내부의 SQL 저장소에 생성 쿼리를 저장해둡니다. 이 후 commit을 하게 되면 저장해두었던 쿼리를 데이터베이스에 보냅니다. 이것을 트랜잭션을 지원하는 쓰기 지연이라고 합니다.
    트랜잭션을 commit 하면 EntityManager는 영속성 컨텍스트를 flush() 합니다. flush() 란 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화하는 작업으로 등록, 수정, 삭제한 Entity 를 데이터베이스에 반영합니다. 즉, 쓰기 지연 SQL 저장소에 모인 쿼리를 데이터베이스에 보냅니다. 이러한 동기화 작업을 거친 후 실제 데이터베이스 트랜잭션을 commit합니다.

* ##### 변경을 감지합니다.
    영속성 컨텍스트에는 이전 flush() 때의 Entity 상태를 복사해서 저장해둔 스냅샷이 존재합니다. JPA는 flsuh() 시점에 스냅샷과 Entity를 비교해 변경된 Entity를 찾습니다. 만약 있다면 각각의 객체에 대한 수정 쿼리를 만들어 쓰기 지연 SQL 저장소에 저장한 후 한꺼번에 데이터베이스로 보내고 데이터베이스 트랜잭션을 commit 합니다. 
    여기서 수정 쿼리는 Entity의 모든 필드를 업데이트 합니다. 이렇게 하면 수정 쿼리를 애플리케이션 로딩 시점에 미리 생성해두고 재사용할 수 있으며, 데이터베이스에 동일한 쿼리를 보낼 때 데이터베이스가 이전에 한 번 파싱된 쿼리를 재사용하기 때문에 성능상 장점이 됩니다.
    변경 감지는 영속성 컨텍스트가 관리하는 영속 상태의 Entity에만 적용 됩니다. 바꿔 말하면, 준영속 상태의 객체는 아무리 수정해도 영속성 컨텍스트가 변경을 감지하지 못합니다.

* ##### 지연 로딩을 수행합니다.
    지연 로딩(Lazy Loading) 이란 실제 객체를 로딩해두고 해당 객체를 실제 사용할 때 영속성 컨텍스트를 통해 데이터를 불러오는 방법입니다.