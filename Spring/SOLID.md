## 좋은 객체 지향 설계의 5가지 (SOLID)

### SRP 단일 책임 원칙
* 정의 : 한 클래스는 하나의 책임만
* 변경이 있을때 파급 효과가 작은 경우 SRP를 잘 따랐다고 할 수 있다.
* 책임의 범위를 적절하게 잘 조절해야함

### OCP 개방-폐쇄 원칙
* 정의 : 확장에는 열려있고, 변경에는 닫혀있어야한다.

* 다형성의 활용
→ 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능 구현
    
    e.g. MemoryMemberRepository → JdbcMemberRepository

##### 확장에는 열려있고 변경에는 닫혀있어야 한다가 무슨 터무니 없는 소리로 인식할수있다. <br> 쉽게 말하면 git에서의 branch를 파서 작업하는 경우와 비슷하다. 


### LSP 리스코프 치환 원칙
* 정의 : 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
* 인터페이스에 대한 구현체를 구현할때 인터페이스의 규약을 전부 지켜야
→ 기능적으로 보장해줘야한다.
e.g. 자동차의 악셀을 뒤로 가게 구현하면 LSP 위반

### ISP 인터페이스 분리 원칙
* 정의 : 특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 낫다.
e.g. 자동차 인터페이스 → 운전 인터페이스, 정비 인터페이스
사용자 인터페이스 → 운전자 인터페이스, 정비사 인터페이스

* ##### 인터페이스가 명확, 대체 가능성 향상

### DIP 의존관계 역전 원칙
* 정의 : 추상화에 의존해야지 구체화에 의존하면 안된다.
→ 클라이언트 코드가 구현 클래스를 바라보는 것이 아닌 인터페이스를 바라보도록!

* 역활에 의존하게 한다는 뜻과 같음
→ 인터페이스에 의존해야 유연한 변경이 가능

e.g. `MemberService`는 `MemoryRepository`도 의존하지만, `MemoryMemberRepository`도 의존함

→ MemoryService가 구현 클래스를 선택
→ DIP 위반 !!

### → 다형성만으로는 OCP, DIP를 지킬 수 없다

## 객체지향 설계와 스프링
#### 스프링은 DI로 OCP, DIP를 가능하게 지원
→ 클라이언트 코드 변경없이 기능 확장 가능

### 정리
* 모든 설계에서 역할과 구현을 분리

* 좋은 객체 지향 설계 : 언제든지 유연하게 변경할 수 있도록 만들기

* 이상적으로는 모든 설계에 인터페이스 부여

: 어떤 db를 사용할지 정해지지 않은 경우

→ 인터페이스의 도입에는 추상화 비용이 발생 : 개발자 코드를 한번 더 열어봐야

→ 기능 확장의 가능성이 없으면 일단 구체 클래스를 사용하고, 향후에 리팩토링해서 인터페이스 도입도 가능