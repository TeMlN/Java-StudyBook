## IoC (제어의 역전)
instance를 생성할때 의존성에 대한 제어권을 개발자가 아닌 spring이 하게 되는 것을 말합니다.

IoC를 통해 인스턴스의 생명주기와 제어권은 IoC 컨테이너가 맡게 됩니다.

만약 IoC가 없다면 의존성에 대한 관리를 개발자가 직접 다 하는 상황을 맞이하게 될겁니다.

## IoC Container
IoC 컨테이너란 Bean으로 등록된 객체들을 관리하는 컨테이너입니다.

IoC 컨테이너는 ApplicationContext 또는 FactoryBean을 사용합니다 (ApplicationContext는 FactoryBean을 상속받습니다.)

참고로 의존성을 주입할때에 두 객체 모두 IoC 컨테이너에 등록되어 있어야 의존성 주입이 가능합니다. 

IoC 컨테이너의 기본 Scope는 SingletonScope이기 때문에 Singleton을 직접 구현하지 않아도 SingleTon 패턴을 사용할 수 있습니다.

## Bean
Bean이란 IoC 컨테이너가 만들어서 직접 그 안에 담고있는 객체

그러면 IoC 컨테이너에 Bean을 등록하려면 어떻게 할까요? 

클래스 레벨에 `@Component`어노테이션이 있는 객체를 스캔하는 `@ComponentScan`과 `@Bean`어노테이션으로 직접 등록해주는 방법이 있다.

## DI 
Dependecy Injection, 의존성 주입
의존성 주입의 종류는 3가지가 있다.
* 생성자 주입
* 필드 주입
* 세터 주입

이 중 spring에서 권장하는 방법은 **생성자 주입**이다
참고로 DI는 의존성을 **외부**에서 주입받는게 핵심이다

생성자 주입을 사용할 시 순환 참조를 방지할 수 있다.

## AOP
AOP란 관점 지향 프로그래밍으로,
예를들면 각 메소드에 공통된 코드가 여럿 중복되어 있으면, 중복되는 코드를
떼어내어 분리하고 각 메소드는 핵심적인 관심사만 포함하도록 한다는 것이다.

여기서 여럿 중복되는 코드들을 Aspect 라고 보면 된다.

## PSA ⭐️
환경의 변화와 관계없이 일관된 방식의 기술로의 접근 환경을 제공하는 추상화 구조.

예를들어 Spring Web MVC 프로젝트를 톰캣이 아닌 네티로 실행시켜도 잘 동작하는 것처럼 수준높은 추상화를 뜻한다.

PSA는 그냥 정말 잘만든 interface라 보면 좋다.

## Servlet ⭐️
클라이언트가 어떠한 요청을 하면 그에 대한 결과를 다시 전송해주는 역할을 수행하는 자바 프로그램

## Dispatcher Servlet ⭐️
HTTP 프로토콜로 들어오는 모든 요청을 가장 먼저 받아 적합한 컨트롤러에 위임해주는 프론트 컨트롤러(Front Controller)

## ORM
객체와 관계형 데이터베이스의 패러다임의 불일치를 해결해주는 기술
객체를 사용하여 간접적으로 데이터베이스를 다룰 수 있다.

* 장점 - 직관적인 코드 + 비즈니스 로직에 집중가능
* 단점 - SQL를 직접 다루지 않으므로 직접 SQL 작성에 어려움을 가질 수 있다.

## 객체지향 프로그래밍 ⭐️
프로그래밍 패러다임중 하나로
프로그래밍에서 필요한 데이터를 추상화 시켜 상태와 행위를 가진 객체를 만들고
그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법입니다.

* #### 객체지향 프로그래밍 특징 ⭐️⭐
1. 추상화 - 객체들이 공통적으로 필요로 하는 속성이나 동작을 하나로 추출해내는 작업
2. 캡슐화 - 하나의 객체에 대해 그 객체가 특정한 목적을 위해 필요한 변수나 메소드를 하나로 묶는 것을 의미
3. 상속 - 부모클래스의 속성과 기능을 이어받아 사용할 수 있게하고 자식 클래스에서 부모 클래스의 변경이 필요하다면 부모 클래스를 건드리지 않고 변경이 가능
4. 다형성 - 같은 함수명을 지녀도 상황에 따라 다른 의미로 해석 될 수 있음

다형성에서 Override와 Overloading의 개념이 등장하는데
Override는 부모 클래스의 메서드를 재정의 하는것이고
Overloading은 메서드명은 같지만 signature를 다르게 설계 하는것이다.

* #### 객체지향 프로그래밍의 장단점 
장점 - 코드 재사용에 용이, 유지보수가 쉽다
단점 - 처리 속도가 상대적으로 느림, 설계시 많은 시간과 노력이 필요

## SOLID 원칙 ⭐️
* SRP(단일 책임의 원칙) - 클래스는 단 하나의 책임을 가져한다.
* OCP(개방-폐쇠의 원칙) - 확장에는 열려있고 변경에는 닫혀 있어야 한다.
* LSP(리스코프 치환의 원칙) - 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상 동작하여야 함.
* ISP(인터페이스 분리 원칙) - 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.
* DIP(의존성 역전 원칙) - 추상화에 의존해야지 구체화에 의존해선 안된다.

## Java Generic
타입을 클래스 내부에서 지정하는게 아닌 외부에서 사용자에 의해 지정되게 하는 기술.
필요에 의해 타입을 지정할 수 있으므로 타입을 유연하게 설계할 수 있다.

## Java Reflection 
구체적인 클래스 타입을 알지 못해도 그 클래스의 메소드, 타입, 변수들에 접근할 수 있도록 해주는 Java API

* 사용되는 경우

IntelliJ에서 자동완성 기능
Spring의 의존성주입

## GC
Garbage Collector는 JVM에 종속되어 있으며
JVM의 Heap 영역에서 동적으로 할당했던 메모리 영역중 필요 없게된 메모리를 주기적으로 삭제해줍니다.

또한 Young 영역에서 일어나는 Minor GC, Old 영역에서 일어나는 Major GC로 나뉩니다.

## JDK
Java Development Kit의 약자,
JRE, javac등의 컴파일러, 디버거등을 포함한다

## JVM
자바 컴파일러가 변환한 바이트코드를 가지고
운영체제가 알 수 있는 기계어로 변환해주는 것이 JVM이 하는 일입니다.

다른 언어들의 코드는 운영체제에 종속적인 반면 자바 코드는 운영체제와 독립적인데 그 이유는 자바 코드와 운영체제 사이에 JVM이 존재하기 때문입니다.

## JPA
Java 진영 ORM 기술 표준으로써

장점으론 영속성 컨텍스트를 제공한다는 점이다.

* #### 영속성 컨텍스트 ⭐️
영속성 컨텍스트란 엔티티를 영구 저장하는 환경이라는 뜻이다.
영속성 컨텍스트가 엔티티를 관리하면 다음과 같은 장점이 있다.

* 1차 캐시
    * 만약 어떤 컬럼을 조회한다면 그 컬럼을 먼저 1차캐시 내에서 조회하고 1차 캐시에 존재하지 않다면 그 때 실질적으로 Database에 조회를 한다, 조회한 컬럼을 다시 1차 캐시에 저장한다, 그렇기 때문에 다시 조회한다면 1차 캐시에서 조회가 되서 성능상 이점을 가져다 준다. 같은 트랜잭션 내에서 같은 1차 캐시를 공유한다.

* 쓰기 지연
    * 요청한 쿼리들을 쿼리가 작성된 시점에 요청을 보내는것이 아닌 쓰기지연 저장소에 저장해 놨다가 트랜잭션이 커밋되는 순간 한번에 DB에 요청 하는것을 말한다. 이로써 얻는 장점은 DB 커넥션 시간을 줄일 수 있다는 점이다. 

* 지연 로딩
    * 연관관계가 있는 한 엔티티를 가져와서 그 엔티티의 일반컬럼을 업데이트 하는 작업을 한다면 연관관계가 걸려있는 엔티티까지 가져오는건 손해이다, 이 문제를 해결하는것이 바로 지연로딩이다 지연로딩은 연관된 엔티티를 프록시 객체로 조회한뒤 실제로 연관된 엔티티를 참조하는 경우 실제 엔티티를 조회해온다.

* 변경 감지
    * 엔티티의 컬럼 값에 변경이 일어나면 별도의 조취를 취하지 않아도 트랜잭션이 커밋될때 이전 엔티티의 스냅샷을 불러와 서로 비교를 한뒤 변경된 점을 update query를 통해 업데이트 한다.

* 동일성보장
    * 동일성 보장이 가능해집니다. == 비교

## 쿠버네티스
쿠버네티스란 컨테이너화된 애플리케이션의 배포, 확장 및 관리를 자동화하는 오픈 소스 시스템

## 도커
컨테이너 기술을 사용하여 애플리케이션에 필요한 환경을 구축하고 테스트 및 배포할 수 있게 해주는 플랫폼

## Kafka
Pub-sub 모델의 메시지 큐

## MSA
모놀리식 아키텍쳐의 단점을 극복하고자 나온 아키텍쳐

각 서비스마다 독립적이므로 독립적으로 배포가 가능하고, 프로젝트내 여러가지 기술스택이 사용될 수 있다.
특정 서비스가 장애가 나도, 다른 서비스에 영향을 끼치지 않는다.

## Primitive Type, Reference Type
Primitive Type은 null이 아닌 기본값이 존재한다. Stack 메모리에 저장된다.
이 기본형 타입에 Null을 허용하지 않을려면 Wrapper Class를 사용하면 된다.

그에 반면 Reference Type은 기본값이 null이다. Heap 메모리에 저장된다.
종류로는 Enum, Class, Interface 등이 있다

## Wrapper Class ⭐️
기본타입에 해당하는 데이터를 객체로 표현하기 위해 포장해주는 클래스

## 추상 클래스와 인터페이스의 차이
추상 클래스는 클래스 내 추상 메소드가 하나 이상 포함되거나 abstract로 정의된 경우를 말하는 반면 인터페이스는 모든 메소드가 추상 메소드입니다.

추상 클래스는 추상 클래스를 상속받아서 기능을 이용하고 확장하는것을 목표로 하고
인터페이스는 인터페이스에 정의된 메소드들을 구현하는것을 목표로 합니다.

## REST, REST API, RESTful
REST는 자원(URI), 행위(Http Method), 자원에 대한 행위의 내용(HTTP Message)으로 이루어져 있습니다.

REST의 특징은 대표적으로

REST는 Client-Server 구조로 이루어져 있으며
Stateless 한 성격을 가지고 있다

* #### REST API 
REST의 특징을 기반으로 구현한 API를 말합니다.
REST API를 올바르게 설계하기 위해선 몇가지 규칙들이 존재합니다.

REST의 원리를 따르고 이런 REST API 규칙들을 잘 지킨 시스템을 RESTful 하다고 말할 수 있습니다.

## Spring과 Spring Boot의 차이점
Spring Boot는 내장 톰캣이 존재하므로 따로 설치하거나 매번 관리해주는 일을 하지 않아도 된다.
stater를 통한 dependecy 자동화

## Optional
null을 허용할 수 있게 해주는 Wrapper 클래스로
참조하더라도 NPE가 일어나지 않고 null을 처리해줄 수 있는 여러 기능들을 제공

## N+1 
연관 관계가 설정된 엔티티를 조회할 경우에 조회된 데이터 갯수(n) 만큼 연관관계의 조회 쿼리가 추가로 발생하여 데이터를 읽어오는 현상.

해결 방법은 entity graph 및 fetch join을 사용하면 된다.

## Cash
데이터나 값을 미리 복사해놓는 임시 장소를 가리키는 말이에요.
캐시의 접근 시간에 비해 원래 데이터를 접근하는 시간을 절약하고 싶은 경우에 사용해요.

## Filter와 Interceptor의 차이점
Filter는 Dispatcher Servlet보다 먼저 위치해 있으므로 서블릿 요청 전에 부가적인 일을 처리할 수 있다.
Interceptor는 Dispatcher Servlet보다 나중에 위치해 있으므로 Dispatcher Servlet이 Controller에 역할을 부임할때 부가적인 일을 처리할 수 있다.

## 쿠키와 세션의 차이점
저장 방식에 따라 분리할 수 있습니다

쿠키는 로컬 브라우저에 저장하고
세션은 웹 서버에 저장합니다.