## IoC (제어의 역전)
instance를 생성할때 의존성에 대한 제어권을 개발자가 아닌 spring이 하게 되는 것을 말합니다.

IoC를 통해 인스턴스의 생명주기와 제어권은 IoC 컨테이너가 맡게 됩니다.

만약 IoC가 없다면 의존성에 대한 관리를 개발자가 직접 다 하는 상황을 맞이하게 될겁니다.

## IoC Container
IoC 컨테이너란 Bean으로 등록된 객체들을 관리하는 컨테이너입니다.

IoC 컨테이너는 ApplicationContext 또는 FactoryBean을 사용합니다 (ApplicationContext는 FactoryBean을 상속받습니다.)

참고로 의존성을 주입할때에 두 객체 모두 IoC 컨테이너에 등록되어 있어야 의존성 주입이 가능합니다. 

IoC 컨테이너의 기본 Scope는 SingletonScope이기 때문에 Singleton을 직접 구현하지 않아도 SingleTon 패턴을 사용할 수 있습니다.

## Bean
Bean이란 IoC 컨테이너가 만들어서 직접 그 안에 담고있는 객체

그러면 IoC 컨테이너에 Bean을 등록하려면 어떻게 할까요? 

클래스 레벨에 `@Component`어노테이션이 있는 객체를 스캔하는 `@ComponentScan`과 `@Bean`어노테이션으로 직접 등록해주는 방법이 있다.

## DI 
Dependecy Injection, 의존성 주입
의존성 주입의 종류는 3가지가 있다.
* 생성자 주입
* 필드 주입
* 세터 주입

이 중 spring에서 권장하는 방법은 **생성자 주입**이다
참고로 DI는 의존성을 **외부**에서 주입받는게 핵심이다

생성자 주입을 사용할 시 순환 참조를 방지할 수 있다.

## AOP
AOP란 관점 지향 프로그래밍으로,
예를들면 각 메소드에 공통된 코드가 여럿 중복되어 있으면, 중복되는 코드를
떼어내어 분리하고 각 메소드는 핵심적인 관심사만 포함하도록 한다는 것이다.

여기서 여럿 중복되는 코드들을 Aspect 라고 보면 된다.

## PSA
환경의 변화와 관계없이 일관된 방식의 기술로의 접근 환경을 제공하는 추상화 구조.

예를들어 Spring Web MVC 프로젝트를 톰캣이 아닌 네티로 실행시켜도 잘 동작하는 것처럼 수준높은 추상화를 뜻한다.

PSA는 그냥 정말 잘만든 interface라 보면 좋다.

## Servlet dispatcher
컨트롤러로 들어가기 전에 맨 앞에서 모든 요청을 받아서 해당하는 controller로 보내주는 역할

## ORM
객체와 관계형 데이터베이스의 패러다임의 불일치를 해결해주는 기술
객체를 사용하여 간접적으로 데이터베이스를 다룰 수 있다.

* 장점 - 직관적인 코드 + 비즈니스 로직에 집중가능
* 단점 - SQL를 직접 다루지 않으므로 직접 SQL 작성에 어려움을 가질 수 있다.

## 객체지향 프로그래밍
프로그래밍 패러다임중 하나로
프로그래밍에서 필요한 데이터를 추상화 시켜 상태와 행위를 가진 객체를 만들고
그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법입니다.

* #### 객체지향 프로그래밍 특징
1. 추상화 - 객체들이 공통적으로 필요로 하는 속성이나 동작을 하나로 추출해내는 작업
2. 캡슐화 - 코드의 재수정 없이 재활용이 가능하게 하고, 접근 제어자를 통해 정보 은닉
3. 상속 - 부모클래스의 속성과 기능을 이어받아 사용할 수 있게하고 자식 클래스에서 부모 클래스의 변경이 필요하다면 부모 클래스를 건드리지 않고 변경이 가능
4. 다형성 - 같은 함수명을 지녀도 상황에 따라 다른 의미로 해석 될 수 있음

다형성에서 Override와 Overloading의 개념이 등장하는데
Override는 부모 클래스의 메서드를 재정의 하는것이고
Overloading은 메서드명은 같지만 signature를 다르게 설계 하는것이다.

* #### 객체지향 프로그래밍의 장단점
장점 - 코드 재사용에 용이, 유지보수가 쉽다
단점 - 처리 속도가 상대적으로 느림, 설계시 많은 시간과 노력이 필요

## SOLID 원칙
* SRP(단일 책임의 원칙) - 클래스는 단 하나의 책임을 가져한다.
* OCP(개방-폐쇠의 원칙) - 확장에는 열려있고 변경에는 닫혀 있어야 한다.
* LSP(리스코프 치환의 원칙) - 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상 동작하여야 함.
* ISP(인터페이스 분리 원칙) - 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.
* DIP(의존성 역전 원칙) - 추상화에 의존해야지 구체화에 의존해선 안된다.

## Java Generic
타입을 클래스 내부에서 지정하는게 아닌 외부에서 사용자에 의해 지정되게 하는 기술.
필요에 의해 타입을 지정할 수 있으므로 타입을 유연하게 설계할 수 있다.

## Java Reflection
객체를 통해 클래스의 정보를 분석해 내는 프로그램 기법